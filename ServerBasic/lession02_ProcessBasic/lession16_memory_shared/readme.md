# 共享内存
## 共享内存
```
◼ 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于
一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介
入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其
他所有共享同一个段的进程可用。
◼ 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据
从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。
```
## 使用步骤
```
◼ 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于
一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介
入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其
他所有共享同一个段的进程可用。
◼ 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据
从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。
```
## 相关函数
```
◼ int shmget(key_t key, size_t size, int shmflg);
    -功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识
        新创建的内存段中的数据都会被初始化为0
    -参数：
        -key:key_t 类型是一个整形，通过这个找到或者创建一个共享内存
            一般使用16进制表示，非0值
        -size：共享内存的大小
        -shmflg:属性
            -访问权限
            -附加属性：创建/判断共享内存是不是存在
                -创建：IPC_CREAT
                -判断共享内存是否存在：IPC_EXCL，需要和IPC_CREAT一起使用
                    IPC_CREAT | IPC_EXCL | 0664
    -返回值：
        失败返回-1，并设置错误号
        成功:>0,返回共享内存的引用的ID,后面操作内存都是通过这个值

◼ void *shmat(int shmid, const void *shmaddr, int shmflg);
    -功能：和当前的进程进行关联
    -参数：
        -shmid:共享内存的ID，由shmget返回值获取
        -shmaddr:共享内存的起始地址，指定NULL，由内核指定
        -shmflg:对共享内存的操作，
            -读：SHM_RDONLY,必须要有读权限
            -读写：0
    -返回值：
        成功：返回共享内存的首(起始)地址。失败(void *)-1

◼ int shmdt(const void *shmaddr);
    -功能：接触当前进程和共享内存的关联
    -参数：
        shmaddr:共享内存的首地址
    -返回值：成功0，失败-1
    
◼ int shmctl(int shmid, int cmd, struct shmid_ds *buf);
    -功能：删除共享内存，共享内存要删除才能消失，创建共享内存的进程被被销毁了对共享内存是没有任 何影响的
    -参数：
        -shmid:共享内存的ID
        -cmd:进行的操作
            -IPC_STAT:获取共享内存的当前状态
            -IPC_SET:设置共享内存的状态
            -IPC_RMID:标记共享内存被销毁
        -buf:需要设置或者获取的共享内存的属性信息
            -IPC_STAT:buf存储数据
            -IPC_SET:buf中需要初始化数据，设置到内核中
            -IPC_RMID:没有用，传递NULL
◼ key_t ftok(const char *pathname, int proj_id)
    -功能：根据指定的路径名和Int值，生成一个共享内存的key
    -参数：
        -pathname:指定一个存在的路径
        -proj_id:int类型的值，但是这个系统调用只会使用其中的1个字节(8位)
            范围：0-255 一般指定一个字符 'a'
```
```
◼ ipcs 用法
 ipcs -a // 打印当前系统中所有的进程间通信方式的信息
 ipcs -m // 打印出使用共享内存进行进程间通信的信息(nattch表示链接数，如果通过shmctl来删除某个共享内存，但是另外有进程还使用，则进程的Key会变成0000000，表示标记删除)
 ipcs -q // 打印出使用消息队列进行进程间通信的信息
 ipcs -s // 打印出使用信号进行进程间通信的信息
◼ ipcrm 用法
 ipcrm -M shmkey // 移除用shmkey创建的共享内存段
 ipcrm -m shmid // 移除用shmid标识的共享内存段
 ipcrm -Q msgkey // 移除用msqkey创建的消息队列
 ipcrm -q msqid // 移除用msqid标识的消息队列
 ipcrm -S semkey // 移除用semkey创建的信号
 ipcrm -s semid // 移除用semid标识的信号

```
## 总结
```
问题1：操作系统如何知道一块内存被几个进程所关联？
    -共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员shm_nattach记录了关联的进程个数
问题2：可不可以对共享内存进行多次删除 shmctl
    -可以的，因为shmctl只是标记删除共享内存，不是直接删除
    -当和共享内存关联的进程数为0时，共享内存才被真正删除
    -当共享内存key为0的时候，表示共享内存被标记删除了，如果一个进程和内存取消关联，那么这个进程就不能继续操作，也不能再次关联

共享内存和内存映射的区别：
1.共享内存可以直接创建，内存映射需要磁盘文件(匿名映射除外)
2.共享内存效率更高
3.内存
    所有进程操作的是同一块共享内存
    内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存
4.数据安全问题
    进程突然退出
        共享内存还存在
        内存映射区就消失了(因为内存映射依赖于进程的缓存区)
    运行进程电脑宕机
        数据存储在共享内存中，没有了
        内存映射中的数据，由于磁盘文件中的数据还在，所以内存映射区中的数据还存在
5.生命周期
    内存映射区：进程推出，内存映射区销毁
    共享内存：进程退出，共享内存还在，手动删除(所有关联进程数为0)或者关机
        如果一个进程退出，自动与共享内存取消关联

```